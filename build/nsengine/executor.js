"use strict";
/**
 * Executor.ts
 *
 * This file contains the Executor class, which is responsible for executing the intermediate code generated by the parser.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Executor = void 0;
const prg = __importStar(require("./program"));
class ExternalFunction {
    constructor(id, signature, callback) {
        this.id = id;
        this.signature = signature;
        this.callback = callback;
    }
}
class Interface {
    constructor(functions) {
        this.functions = functions;
    }
}
class Executor {
    constructor(maxStackSize = 1024) {
        this.stack = [];
        this.heap = [];
        this.ip = 0;
        this.sp = 0;
        this.fp = 0;
    }
    execute(program) {
        this.program = program;
        this.ip = 0;
        this.fp = 0;
        while (program.instructions[this.ip].opcode != prg.OP_TERM) {
            //this.printStack();
            this.executeInstruction(program.instructions[this.ip]);
        }
        if (this.stack.length > 0) {
            return this.stack.pop();
        }
        return 0;
    }
    printStack() {
        console.log("Stack: " + this.stack);
    }
    printHeap() {
        console.log("Heap: " + this.heap);
    }
    executeInstruction(instruction) {
        let a, b, c, d, e, f;
        switch (instruction.opcode) {
            case prg.OP_LOAD_CONST_BOOL:
                this.stack.push(instruction.operand);
                this.ip++;
                this.sp++;
            case prg.OP_LOAD_CONST_INT:
                this.stack.push(instruction.operand);
                this.ip++;
                this.sp++;
                break;
            case prg.OP_LOAD_CONST_FLOAT:
                this.stack.push(instruction.operand);
                this.ip++;
                this.sp++;
                break;
            case prg.OP_LOAD_CONST_STRING:
                this.stack.push(instruction.operand);
                this.ip++;
                this.sp++;
                break;
            case prg.OP_LOAD_CONST_NULL:
                this.stack.push(null);
                this.ip++;
                this.sp++;
                break;
            case prg.OP_ADDi:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a + b);
                this.ip++;
                break;
            case prg.OP_ADDf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a + b);
                this.ip++;
                break;
            case prg.OP_SUBi:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a - b);
                this.ip++;
                break;
            case prg.OP_SUBf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a - b);
                this.ip++;
                break;
            case prg.OP_MULi:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a * b);
                this.ip++;
                break;
            case prg.OP_MULf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a * b);
                this.ip++;
                break;
            case prg.OP_DIVi:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a / b);
                this.ip++;
                break;
            case prg.OP_DIVf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a / b);
                this.ip++;
                break;
            case prg.OP_MODi:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a % b);
                this.ip++;
                break;
            case prg.OP_MODf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a % b);
                this.ip++;
                break;
            case prg.OP_POWi:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a ** b);
                this.ip++;
                break;
            case prg.OP_POWf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a ** b);
                this.ip++;
                break;
            case prg.OP_NEGi:
                a = this.stack.pop();
                this.stack.push(-a);
                this.ip++;
                break;
            case prg.OP_NEGf:
                a = this.stack.pop();
                this.stack.push(-a);
                this.ip++;
                break;
            case prg.OP_INT_TO_FLOAT:
                a = this.stack.pop();
                this.stack.push(a);
                this.ip++;
                break;
            case prg.OP_FLOAT_TO_INT:
                a = this.stack.pop();
                this.stack.push(Math.floor(a));
                this.ip++;
                break;
            case prg.OP_INT_TO_STRING:
                a = this.stack.pop();
                this.stack.push(a.toString());
                this.ip++;
                break;
            case prg.OP_FLOAT_TO_STRING:
                a = this.stack.pop();
                this.stack.push(a.toString());
                this.ip++;
                break;
            case prg.OP_JUMP:
                this.ip = instruction.operand;
                break;
            case prg.OP_BRANCH_FALSE:
                a = this.stack.pop();
                if (!a) {
                    this.ip = instruction.operand;
                }
                else {
                    this.ip++;
                }
                break;
            case prg.OP_BRANCH_TRUE:
                a = this.stack.pop();
                if (a) {
                    this.ip = instruction.operand;
                }
                else {
                    this.ip++;
                }
                break;
            case prg.OP_EQUALi:
            case prg.OP_EQUALf:
            case prg.OP_EQUALb:
            case prg.OP_EQUALs:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a == b);
                this.ip++;
                break;
            case prg.OP_NOT_EQUALi:
            case prg.OP_NOT_EQUALf:
            case prg.OP_NOT_EQUALb:
            case prg.OP_NOT_EQUALs:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a != b);
                this.ip++;
                break;
            case prg.OP_GREATER_THANi:
            case prg.OP_GREATER_THANf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a > b);
                this.ip++;
                break;
            case prg.OP_LESS_THANi:
            case prg.OP_LESS_THANf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a < b);
                this.ip++;
                break;
            case prg.OP_GREATER_THAN_OR_EQUALi:
            case prg.OP_GREATER_THAN_OR_EQUALf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a >= b);
                this.ip++;
                break;
            case prg.OP_LESS_THAN_OR_EQUALi:
            case prg.OP_LESS_THAN_OR_EQUALf:
                b = this.stack.pop();
                a = this.stack.pop();
                this.stack.push(a <= b);
                this.ip++;
                break;
            case prg.OP_NEGi:
            case prg.OP_NEGf:
                a = this.stack.pop();
                this.stack.push(-a);
                this.ip++;
                break;
            case prg.OP_LOAD_LOCAL:
                this.stack.push(this.stack[this.fp + instruction.operand]);
                this.ip++;
                break;
            case prg.OP_STORE_LOCAL:
                this.stack[this.fp + instruction.operand] = this.stack.pop();
                this.ip++;
                break;
            case prg.OP_LOAD_EXTERNAL:
                this.stack.push(instruction.operand);
                this.ip++;
                break;
            case prg.OP_ALLOC_STACK:
                for (let i = 0; i < instruction.operand; i++) {
                    this.stack.push(null);
                    this.sp++;
                }
                this.ip++;
                break;
            case prg.OP_POP_STACK:
                for (let i = 0; i < instruction.operand; i++) {
                    this.stack.pop();
                    this.sp--;
                }
                this.ip++;
                break;
            case prg.OP_ALLOC_HEAP:
                for (let i = 0; i < instruction.operand; i++) {
                    this.heap.push(null);
                }
                this.ip++;
                break;
            case prg.OP_POP_HEAP:
                for (let i = 0; i < instruction.operand; i++) {
                    this.heap.pop();
                }
                this.ip++;
                break;
            case prg.OP_LOAD_MEMBER:
                a = this.stack.pop();
                this.stack.push(a[instruction.operand]);
                this.ip++;
                break;
            case prg.OP_STORE_MEMBER:
                a = this.stack.pop();
                a[instruction.operand] = this.stack.pop();
                this.ip++;
                break;
            case prg.OP_LOAD_ELEMENT:
                a = this.stack.pop();
                b = this.stack.pop();
                this.stack.push(a[b]);
                this.ip++;
                break;
            case prg.OP_STORE_ELEMENT:
                a = this.stack.pop();
                b = this.stack.pop();
                c = this.stack.pop();
                a[b] = c;
                this.ip++;
                break;
            case prg.OP_CALL_INTERNAL:
                // call other functions in the program
                this.ip++;
                break;
            case prg.OP_CALL_EXTERNAL:
                a = this.stack.pop();
                if (instruction.operand < 1) {
                    this.stack.push(a());
                }
                else {
                    b = [];
                    for (let i = 0; i < instruction.operand; i++) {
                        b.push(this.stack.pop());
                    }
                    this.stack.push(a(...b.reverse()));
                }
                this.ip++;
                break;
            case prg.OP_INCREMENT_LOCAL_POST:
                this.stack[this.fp + instruction.operand]++;
                this.ip++;
                break;
            case prg.OP_DECREMENT_LOCAL_POST:
                this.stack[this.fp + instruction.operand]--;
                this.ip++;
                break;
            default:
                throw new Error(`Unknown opcode: ${instruction.opcode}`);
        }
    }
}
exports.Executor = Executor;
